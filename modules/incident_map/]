<?php

/**
 * Implements hook_menu().
 */
function incident_map_menu() {
  $items = array();

  foreach (incident_map_geojson() as $map) {
     $item = array(
      'title' => $map['name'],
      'description' => '',
      'page callback' => 'incident_map_json_menu_callback',
      'page arguments' => array($map['callback']),
      'access arguments' => array(),
      'type' => MENU_NORMAL_ITEM,
    );

    if (isset($map['arguments'])) {
      $item['page arguments'] += $map['arguments'];
    }

    if (isset($map['access'])) {
      $item['access arguments'] += $map['access'];
    }

    $items["geojson/{$map['uri']}"] = $item;
  }

  error_log(print_r($items, 1), 0);

  return $items;
}

/**
 * Implements hook_libraries_info().
 */
function incident_map_libraries_info() {
  return array(
    'geojson' => array(
      'name' => 'GeoJSON',
      'vendor url' => 'https://github.com/affinitybridge/php-geojson',
      'download url' => 'git@github.com:affinitybridge/php-geojson.git',
      'version' => '0.0.1',
      'files' => array(
        'php' => array(
          'geojson.php'
        ),
      ),
    ),
  );
}

/**
 * GeoJSON menu callback.
 *
 * Get's GeoJSON object from arguments and sends it to client with appropriate
 * headers.
 */
function incident_map_json_menu_callback() {
  $args = func_get_args();
  $callback = array_shift($args);

  $data = call_user_func_array($callback, $args);

  if (!$data) {
    return MENU_NOT_FOUND;
  }
  else if (is_numeric($data)) {
    return $data;
  }

  incident_map_response_json($data);
}

/**
 * Sends a JSON encoded data to client as a properly defined JSON response.
 */
function incident_map_response_json($data) {
  // Send results to client as json and terminate request.
  drupal_add_http_header('Content-Type', 'application/json; charset=utf-8');
  print drupal_json_encode($data);
  ajax_footer();
}

/**
 * Get all incident map geojson.
 *
 * Invokes hook_geojson_info().
 */
function incident_map_geojson() {
  // TODO: Cache here.
  $resources = module_invoke_all('geojson_info');
  return $resources;
}

/**
 * Implements hook_incident_map_resources().
 */
function incident_map_geojson_info() {
  return array(
    array(
      'uri' => 'incident-reports',
      'name' => 'Incident Map',
      'callback' => 'incident_map_report_geojson',
      'arguments' => array(),
      'access' => array('access content'),
    ),
  );
}

/**
 * Callback for generating incident map geojson.
 */
function incident_map_report_geojson() {
  $library = libraries_load('geojson');
  if (!$library || empty($library['installed'])) {
    return MENU_NOT_FOUND;
  }

  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'incident_report')
    ->fieldCondition('field_incident_geolocation', 'wkt', 'NULL', '!=');

  $result = $query->execute();
  $nids = empty($result['node']) ? array() : array_keys($result['node']);
  $wrappers = entity_metadata_wrapper('list<node>', $nids);

  $factory = function ($wrapper) {
    $geofield = $wrapper->field_incident_geolocation;
    $geom = create_geophp_geometry($geofield, 'incident_map_incident_report_get_geom');
    if (empty($geom)) return NULL;

    $properties = array();

    return geojson_feature($geom, $properties);
  };

  return geojson_feature_collection($wrappers, $factory);
}

function incident_map_incident_report_get_geom($wrapper) {
  geophp_load();
  return geoPHP::load($wrapper->wkt->value(), 'wkt');
}
